import { useEffect, useState } from 'react';
import { useAction } from 'convex/react';
// @ts-ignore generated by Convex (path provided by Convex codegen)
import { api } from '../../convex/_generated/api';

// Types mirrored from our UI usage to avoid importing client-side GitHub services
export type GhUser = {
  login: string;
  name: string | null;
  avatar_url: string;
  bio: string | null;
  followers: number;
  html_url: string;
  location?: string | null;
  blog?: string | null;
};
export type PinnedRepo = {
  id: string | number;
  name: string;
  description: string | null;
  stargazerCount?: number;
  url?: string;
  html_url?: string;
  primaryLanguage?: { name: string; color: string } | null;
  language?: string | null;
};
export type ContributionDay = { date: string; contributionCount: number; color: string };

// All GitHub requests are served from Convex; no client env token/username needed.

export function useGithubProfile(username: string, pollMs = 600000) {
  const getProfile = (() => { try { return useAction((api as any).github.getProfile); } catch { return null; } })();
  // Instant hydrate from cache
  const cacheKey = `gh:profile:${username || 'auto'}`;
  const cached = typeof window !== 'undefined' ? window.localStorage.getItem(cacheKey) : null;
  const cachedVal: GhUser | null = cached ? (() => { try { const o = JSON.parse(cached); return o.d && (Date.now()-o.t<600000) ? o.d as GhUser : null; } catch { return null; } })() : null;
  const [data, setData] = useState<GhUser | null>(cachedVal);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    let alive = true;
    const fetchOnce = () => {
      setLoading(true);
      const run = async () => {
        try {
          if (getProfile) {
            const d = await getProfile({ username: username === 'auto' ? undefined : username });
            if (alive) {
              setData(d as any);
              try { localStorage.setItem(cacheKey, JSON.stringify({ t: Date.now(), d })); } catch {}
            }
          }
        } catch (e) {
          if (alive) setError(String(e));
        } finally {
          if (alive) setLoading(false);
        }
      };
      run();
    };
    // If we had cache, start background refresh slightly later to avoid jank
    if (cachedVal) setTimeout(fetchOnce, 50); else fetchOnce();
    const t = pollMs ? setInterval(fetchOnce, pollMs) : null;
    return () => {
      alive = false;
      if (t) clearInterval(t);
    };
  }, [username, pollMs]);
  return { data, loading, error };
}

export function usePinnedRepos(username: string, pollMs = 600000) {
  const getPinnedAction = (() => { try { return useAction((api as any).github.getPinned); } catch { return null; } })();
  const cacheKey = `gh:pinned:${username || 'auto'}`;
  const cached = typeof window !== 'undefined' ? window.localStorage.getItem(cacheKey) : null;
  const cachedVal: PinnedRepo[] | null = cached ? (() => { try { const o = JSON.parse(cached); return o.d && (Date.now()-o.t<600000) ? o.d as PinnedRepo[] : null; } catch { return null; } })() : null;
  const [data, setData] = useState<PinnedRepo[] | null>(cachedVal);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    let alive = true;
    const run = async () => {
      setLoading(true);
      try {
        if (!getPinnedAction) throw new Error('Convex not connected');
        const pinned = await getPinnedAction({ username: username === 'auto' ? undefined : username, limit: 6 });
        if (alive) {
          setData(pinned as any);
          try { localStorage.setItem(cacheKey, JSON.stringify({ t: Date.now(), d: pinned })); } catch {}
        }
      } catch (e) {
        if (alive) setError(String(e));
      } finally {
        if (alive) setLoading(false);
      }
    };
    if (cachedVal) setTimeout(run, 50); else run();
    const t = pollMs ? setInterval(run, pollMs) : null;
    return () => {
      alive = false;
      if (t) clearInterval(t);
    };
  }, [username, pollMs]);
  return { data, loading, error, usesGraphql: true };
}

export function useContributions(username: string, pollMs = 600000) {
  const getContribAction = (() => { try { return useAction((api as any).github.getContributions); } catch { return null; } })();
  const cacheKey = `gh:contrib:${username || 'auto'}`;
  const cached = typeof window !== 'undefined' ? window.localStorage.getItem(cacheKey) : null;
  const cachedVal: ContributionDay[] | null = cached ? (() => { try { const o = JSON.parse(cached); return o.d && (Date.now()-o.t<600000) ? o.d as ContributionDay[] : null; } catch { return null; } })() : null;
  const [data, setData] = useState<ContributionDay[] | null>(cachedVal);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    let alive = true;
    if (!getContribAction) { setError('Convex not connected'); setLoading(false); return; }
    const run = () => {
      setLoading(true);
      const go = async () => {
        try {
          const res = (await getContribAction({ username: username === 'auto' ? undefined : username })) as any;
          if (alive) {
            const next = res.enabled ? (res.days as any) : null;
            setData(next);
            try { localStorage.setItem(cacheKey, JSON.stringify({ t: Date.now(), d: next })); } catch {}
          }
        } catch (e) {
          if (alive) setError(String(e));
        } finally {
          if (alive) setLoading(false);
        }
      };
      go();
    };
    if (cachedVal) setTimeout(run, 50); else run();
    const t = pollMs ? setInterval(run, pollMs) : null;
    return () => {
      alive = false;
      if (t) clearInterval(t);
    };
  }, [username, pollMs]);
  return { data, loading, error, enabled: true };
}

export function useGithubStatus() {
  const status = (() => { try { return useAction((api as any).github.getStatus); } catch { return null; } })();
  const [data, setData] = useState<{ username: string; hasToken: boolean } | null>(null);
  useEffect(() => {
    let alive = true;
    const run = async () => {
      try {
        if (status) {
          const s = await status({});
          if (alive) setData(s as any);
        }
      } catch {}
    };
    run();
    return () => { alive = false; };
  }, []);
  return data;
}
